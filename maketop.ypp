/**********************************************************************/
/*	maketop.ypp - input file for the bison parser	              */
/*		      generator. Specifies the grammar for            */
/*		      topologies of nodes in the IoT network          */
/*							              */
/*  The specification for the topology is as follows:		      */
/*	1. The basic elements of the topologies are rings, stars,     */
/*	   complete graphs, other predefined shapes, and individual   */
/*	   nodes. These elements are used to build up the arbitrary   */
/*	   graphs.						      */
/*								      */
/* 	2. The elements that have multiple nodes have a fixed	      */
/*	ordering for the nodes. For example,			      */
/*								      */
/* 	    a. The center of a star is numbered 0, the remaining      */
/* 	       indices number the nodes clockwise. If a spoke node    */
/* 	       is connected first, that becomes 1 (but actually,      */
/* 	       the order doesn't matter).			      */
/*								      */
/*          b. A bus has index 0 for one of the end nodes (the head   */
/*	       if it is	unidirectional) and the numbering proceeds    */
/*	       to the end/tail.					      */
/*								      */
/*          c. When a ring (or complete graph) is connected to        */
/*	       another element, the node that is first connected is   */
/*	       numbered 0, the remaining follow clockwise.            */
/*								      */
/* 	Other kinds of default behavior could be implemented as well. */
/*								      */
/*	3. ->, <- and <-> specify connections between the elements.   */
/*                                                                    */
/*	4. A series of commands can be specified to make the          */
/*	connections.                                                  */
/*                                                                    */
/*	5. For example, a graph like                                  */
/*                                                                    */
/*	    n                  n  n  n                                */
/*	   / \                  \ | /                                 */
/*	  n   n - n - n - n - n - n - n                               */
/*	   \ /                    | \                                 */
/*	    n                     n  n                                */
/*								      */
/*	could be specified using the commands:			      */
/*                                                                    */
/*	a = ring(4);                                                  */
/*	b = bus(3);                                                   */
/*	a <-> b;      // We can have default behaviour for connecting */
/*	              // certain types of elements                    */
/*	c = star(6);                                                  */
/*	b[2] <-> c[0];                                                */
/*	d = node();                                                   */
/*	d <-> c[1];                                                   */
/*	maketop;                                                      */
/*                                                                    */
/*	The graph looks like:                                         */
/*                                                                    */
/*	    a_3                               c_4 c_5 c_6             */
/*         /   \                                 \ | /                */
/*      a_2    a_0 - b_0 - b_1 - b_2 - c_0 - c_1 - d                  */
/*         \   /                                   | \                */
/*          a_1                                   c_3 c_2             */
/*                                                                    */
/*	6. The output would be the usual adjacency list               */
/*	representation, with the nodes named a_0, a_1, b_0, etc.      */
/*								      */
/**********************************************************************/

%start program
%token MAKETOP
%token LEFT RIGHT BI RING EQ LINEAR COMPLETE STAR LEFTPAREN RIGHTPAREN

%{
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <fstream>

#include <list>
#include <string>

#define NAMLEN 128
#define MAX 45

#ifdef DEBUG
#  define debug(x) x
#else
#  define debug(x)
#endif

void yyerror(const char *s){};
extern "C" int yylex();
extern "C" int yyparse();

struct node {
	char name[NAMLEN+3];
	std::list<std::string> adj_list;
};

std::list<struct node> nodes;

//int nnodes = 0;

void add_neighbour(struct node *curr_node, char *neighbour);
void add_ring(char *family_name, int n);
void add_linear(char *family_name, int n);
void add_complete(char *family_name, int n);
void add_star(char *family_name, int n);
void print_node(struct node curr_node);
void output_to_file();

%}

%union {
	int ival;
	char *node_name_value;
}

%token <ival> INT
%token <node_name_value> NODE

%%

program : statements MAKETOP {printf ("End\n"); output_to_file(); exit(1); }
;

statement : assign | connect
;

connect : NODE LEFT NODE | NODE RIGHT NODE | NODE BI NODE
;

assign : NODE EQ RING LEFTPAREN INT RIGHTPAREN
		{add_ring($1, $5);} |
	 NODE EQ LINEAR LEFTPAREN INT RIGHTPAREN
		{add_linear($1, $5);} |
	 NODE EQ COMPLETE LEFTPAREN INT RIGHTPAREN
		{add_complete($1, $5);} |
	 NODE EQ STAR LEFTPAREN INT RIGHTPAREN
		{add_star($1, $5);}
;

statements : /* empty */|
	statement statements
	;
%%

int main( int argc, char *argv[] )
{ //extern FILE *yyin;
  //++argv; −−argc;
  //yyin = fopen( argv[0], ”r” );
  //int nnodes = 0;
  struct node nodes[MAX];
  //int yydebug = 1;
  //int errors = 0;
  yyparse ();
}

void yyerror (char *s) /* Called by yyparse on error */
{
printf ("%s\n", s);
}

int node_check(int n) {
  if (n > MAX)
    return 0;
  return 1;
}

void error_message(const char *msg) {
  //int i, j;
  fprintf(stderr, "%s", msg);
  /*for (i = 0; i < nnodes; i++) {
    for (j = 0; j < nodes[i].nadj; j++) {
      free(nodes[i].adj_list[j]);
    }
    free(nodes[i].adj_list);
    }*/
  exit(1);
}

/*void add_neighbour(struct node *curr_node, char *neighbour) {
  char **temp_list;
  if ((*curr_node).nadj == 0) {
    (*curr_node).nadj++;
    (*curr_node).adj_list = (char**)malloc((*curr_node).nadj*sizeof(char *));
    if ((*curr_node).adj_list == NULL) {
      error_message("Memory could not be allocated");
    }
  }
  else {
    (*curr_node).nadj++;
    temp_list = (char**)realloc((*curr_node).adj_list, (*curr_node).nadj*sizeof(char *));
    if (temp_list == NULL) {
      error_message("Memory could not be allocated");
    }
    (*curr_node).adj_list = temp_list;
  }
  (*curr_node).adj_list[(*curr_node).nadj-1] = (char*)malloc(sizeof(strlen(neighbour)));
  strcpy((*curr_node).adj_list[(*curr_node).nadj-1], neighbour);
  }*/

/**************************************************************/
/*	add_ring - function takes a family_name	and the       */
/*		   number of nodes in the ring, and adds all  */
/*		   nodes to the global nodes list	      */
/**************************************************************/

void add_ring(char *family_name, int n) {
  int i;				/* index for nodes */
  char neighbour[NAMLEN+3];		/* C style string to hold neighbour name */
  std::string neighbour_string;		/* std::string for neighbour name to push onto list */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* Loop through nodes in ring */

  for (i = 0; i < n; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Insert name of next node */
    sprintf(new_node.name, "%s_%d", family_name, i);
    //printf("Got here");
    printf("\nName: %s\n", new_node.name);

    /* Clear adjacency list from the last node */
    new_node.adj_list.clear();

    /* Add first neighbour */
    sprintf(neighbour, "%s_%d", family_name, (((i-1) % n) + n)%n);
    neighbour_string = std::string(neighbour);
    new_node.adj_list.push_back(neighbour_string);

    /* Add second neighbour */
    sprintf(neighbour, "%s_%d", family_name, (i+1) % n);
    neighbour_string = std::string(neighbour);
    new_node.adj_list.push_back(neighbour_string);

    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }
}

/**************************************************************/
/*	add_linear - function takes a family_name and the     */
/*		   number of nodes in the bus, and adds all   */
/*		   nodes to the global nodes list	      */
/**************************************************************/

void add_linear(char *family_name, int n) {
  int i = 0;				/* index for nodes */
  char neighbour[NAMLEN+3];		/* C style string to hold neighbour name */
  std::string neighbour_string;		/* std::string for neighbour name to push onto list */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* For the first node */

  /* Check for node limit */
  if(!node_check(nodes.size()))
    error_message("Node limit exceeded");

  /* Insert name of next node */
  sprintf(new_node.name, "%s_%d", family_name, i);
  //printf("Got here");
  printf("\nName: %s\n", new_node.name);

  /* Clear adjacency list from the last node */
  new_node.adj_list.clear();

  /* Add first neighbour */
  sprintf(neighbour, "%s_%d", family_name, ((i+1) % n));
  neighbour_string = std::string(neighbour);
  new_node.adj_list.push_back(neighbour_string);

  /* Push node on to global nodes list */
  nodes.push_back(new_node);

  /* Print details of node just added */
  print_node(nodes.back());

  /* Loop through nodes in bus */

  for (i = 1; i < n-1; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Insert name of next node */
    sprintf(new_node.name, "%s_%d", family_name, i);
    //printf("Got here");
    printf("\nName: %s\n", new_node.name);

    /* Clear adjacency list from the last node */
    new_node.adj_list.clear();

    /* Add first neighbour */
    sprintf(neighbour, "%s_%d", family_name, (((i-1) % n) + n)%n);
    neighbour_string = std::string(neighbour);
    new_node.adj_list.push_back(neighbour_string);

    /* Add second neighbour */
    sprintf(neighbour, "%s_%d", family_name, (i+1) % n);
    neighbour_string = std::string(neighbour);
    new_node.adj_list.push_back(neighbour_string);

    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }

  /* Last node */

  /* Check for node limit */
  if(!node_check(nodes.size()))
    error_message("Node limit exceeded");

  /* Insert name of next node */
  sprintf(new_node.name, "%s_%d", family_name, i);
  //printf("Got here");
  printf("\nName: %s\n", new_node.name);

  /* Clear adjacency list from the last node */
  new_node.adj_list.clear();

  /* Add first neighbour */
  sprintf(neighbour, "%s_%d", family_name, (((i-1) % n) + n)%n);
  neighbour_string = std::string(neighbour);
  new_node.adj_list.push_back(neighbour_string);

  /* Push node on to global nodes list */
  nodes.push_back(new_node);

  /* Print details of node just added */
  print_node(nodes.back());
}

/**************************************************************/
/*	add_complete - function takes a family_name and the   */
/*		       number of nodes in the complete graph, */
/*		       and adds all nodes to the global nodes */
/*		       list.				      */
/**************************************************************/

void add_complete(char *family_name, int n) {
  int i, j;				/* indices for nodes */
  char neighbour[NAMLEN+3];		/* C style string to hold neighbour name */
  std::string neighbour_string;		/* std::string for neighbour name to push onto list */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* Loop through nodes in ring */

  for (i = 0; i < n; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Insert name of next node */
    sprintf(new_node.name, "%s_%d", family_name, i);
    //printf("Got here");
    printf("\nName: %s\n", new_node.name);

    /* Clear adjacency list from the last node */
    new_node.adj_list.clear();

    /* Add all the neighbours */

    for (j = 0; j < n; j++) {
      /* Don't add a node to it's adjacency list */
      if (i == j)
	continue;

      sprintf(neighbour, "%s_%d", family_name, j);
      neighbour_string = std::string(neighbour);
      new_node.adj_list.push_back(neighbour_string);
    }
    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }
}
/**************************************************************/
/*	add_star - function takes a family_name	and the       */
/*		   number of nodes in the star, and adds all  */
/*		   nodes to the global nodes list	      */
/**************************************************************/

void add_star(char *family_name, int n) {
  int i = 0, j;				/* index for nodes */
  char neighbour[NAMLEN+3];		/* C style string to hold neighbour name */
  std::string neighbour_string;		/* std::string for neighbour name to push onto list */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* Central node */

  /* Check for node limit */
  if(!node_check(nodes.size()))
    error_message("Node limit exceeded");

  /* Insert name of next node */
  sprintf(new_node.name, "%s_%d", family_name, i);
  //printf("Got here");
  printf("\nName: %s\n", new_node.name);

  /* Clear adjacency list from the last node */
  new_node.adj_list.clear();

  /* Add neighbours */

  for (j = 1; j < n; j++) {
    sprintf(neighbour, "%s_%d", family_name, j);
    neighbour_string = std::string(neighbour);
    new_node.adj_list.push_back(neighbour_string);
  }

  /* Push node on to global nodes list */
  nodes.push_back(new_node);

  /* Print details of node just added */
  print_node(nodes.back());

  /* Loop through nodes in ring */

  for (i = 1; i < n; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Insert name of next node */
    sprintf(new_node.name, "%s_%d", family_name, i);
    //printf("Got here");
    printf("\nName: %s\n", new_node.name);

    /* Clear adjacency list from the last node */
    new_node.adj_list.clear();

    /* Add first neighbour */
    sprintf(neighbour, "%s_%d", family_name, 0);
    neighbour_string = std::string(neighbour);
    new_node.adj_list.push_back(neighbour_string);

    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }
}

/**************************************************************/
/*	print_node - Print the details of a single node       */
/**************************************************************/

void print_node(struct node curr_node) {
  std::cout << "\nNode name: " << curr_node.name;
  std::cout << "\nNumber of adjacent nodes: " << curr_node.adj_list.size();
  std::cout << "\nAdjacent nodes: ";

  for(std::list<std::string>::iterator iter = curr_node.adj_list.begin(); iter != curr_node.adj_list.end(); iter++){
	std::cout << *iter << " ";;
  }

  std::cout << std::endl;
}

/**************************************************************/
/*	output_to_file - Write the adjacency lists to file    */
/**************************************************************/

void output_to_file() {
	const char *filename = "output_file";

	std::ofstream fout(filename);

	for(std::list<struct node>::iterator curr_node = nodes.begin(); curr_node != nodes.end(); curr_node++) {
		fout << (*curr_node).name << ":";
		for(std::list<std::string>::iterator curr_element = (*curr_node).adj_list.begin(); curr_element != (*curr_node).adj_list.end(); curr_element++){
			 fout << " " << *curr_element;
		}
		fout << std::endl;
	}
	fout.close();
}
