/**********************************************************************/
/*	maketop.ypp - input file for the bison parser	              */
/*		      generator. Specifies the grammar for            */
/*		      topologies of nodes in the IoT network          */
/*							              */
/*  The specification for the topology is as follows:		      */
/*	1. The basic elements of the topologies are rings, stars,     */
/*	   complete graphs, other predefined shapes, and individual   */
/*	   nodes. These elements are used to build up the arbitrary   */
/*	   graphs.						      */
/*								      */
/* 	2. The elements that have multiple nodes have a fixed	      */
/*	ordering for the nodes. For example,			      */
/*								      */
/* 	    a. The center of a star is numbered 0, the remaining      */
/* 	       indices number the nodes clockwise. If a spoke node    */
/* 	       is connected first, that becomes 1 (but actually,      */
/* 	       the order doesn't matter).			      */
/*								      */
/*          b. A bus has index 0 for one of the end nodes (the head   */
/*	       if it is	unidirectional) and the numbering proceeds    */
/*	       to the end/tail.					      */
/*								      */
/*          c. When a ring (or complete graph) is connected to        */
/*	       another element, the node that is first connected is   */
/*	       numbered 0, the remaining follow clockwise.            */
/*								      */
/* 	Other kinds of default behavior could be implemented as well. */
/*								      */
/*	3. ->, <- and <-> specify connections between the elements.   */
/*                                                                    */
/*	4. A series of commands can be specified to make the          */
/*	connections.                                                  */
/*                                                                    */
/*	5. For example, a graph like                                  */
/*                                                                    */
/*	    n                  n  n  n                                */
/*	   / \                  \ | /                                 */
/*	  n   n - n - n - n - n - n - n                               */
/*	   \ /                    | \                                 */
/*	    n                     n  n                                */
/*								      */
/*	could be specified using the commands:			      */
/*                                                                    */
/*	a = ring(4);                                                  */
/*	b = bus(3);                                                   */
/*	a <-> b;      // We can have default behaviour for connecting */
/*	              // certain types of elements                    */
/*	c = star(6);                                                  */
/*	b[2] <-> c[0];                                                */
/*	d = node();                                                   */
/*	d <-> c[1];                                                   */
/*	maketop;                                                      */
/*                                                                    */
/*	The graph looks like:                                         */
/*                                                                    */
/*	    a_3                               c_4 c_5 c_6             */
/*         /   \                                 \ | /                */
/*      a_2    a_0 - b_0 - b_1 - b_2 - c_0 - c_1 - d                  */
/*         \   /                                   | \                */
/*          a_1                                   c_3 c_2             */
/*                                                                    */
/*	6. The output would be the usual adjacency list               */
/*	representation, with the nodes named a_0, a_1, b_0, etc.      */
/*								      */
/**********************************************************************/

%start program
%token MAKETOP
%token LEFT RIGHT BI RING EQ LINEAR COMPLETE STAR LEFTPAREN RIGHTPAREN COMMA ADD DELETE

%{

#include "Topology.hpp"

void yyerror(const char *s){};
extern "C" int yylex();
extern "C" int yyparse();
extern void yyrestart(FILE *input_file);
extern "C" FILE* yyin;

%}

%union {
	int ival;
	char *node_name_value;
}

%token <ival> INT
%token <node_name_value> NODE
%type <node_name_value> node
%type <ival> int_node

%%

program : statements MAKETOP {debug(printf ("End\n")); output_to_file(); exit(1); }
;

statement : assign {printf(">>> ");}| connect {printf(">>> ");}
;

node: NODE
	{
	  $$=$1;
	  std::string name = std::string($1);
	  if (name.length() > NAMLEN) {
	    std::cout << "Node name is too long" << std::endl;
	    YYABORT;
	  }
	}
;

connect : node LEFT node |
	  node RIGHT node |
	  node BI node |
	  ADD node node
		{
                  std::string sender = std::string($2);
		  std::string receiver = std::string($3);
		  add_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  ADD node RIGHT node
		{
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  add_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  ADD node BI node
		{
		  int s = 1;
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  add_connection(*node_lookup(sender), *node_lookup(receiver), s);
		  print_node(*node_lookup(sender));
		} |
	  DELETE node node
		{
		  std::string sender = std::string($2);
		  std::string receiver = std::string($3);
		  delete_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  DELETE node RIGHT node
		{
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  delete_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  DELETE node BI node
		{
		  int s = 1;
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  delete_connection(*node_lookup(sender), *node_lookup(receiver), s);
		  print_node(*node_lookup(sender));
		}
;

int_node: INT
{
  $$ = $1;
  if (nodes.size() + $1 > MAX) {
    std::cout << "Node limit exceeded" << std::endl;
    YYABORT;
  }
};

assign : node EQ RING LEFTPAREN int_node RIGHTPAREN
		{add_ring($1, $5);} |
	 node EQ LINEAR LEFTPAREN int_node RIGHTPAREN
		{add_linear($1, $5);} |
	 node EQ COMPLETE LEFTPAREN int_node RIGHTPAREN
		{add_complete($1, $5);} |
	 node EQ STAR LEFTPAREN int_node RIGHTPAREN
		{add_star($1, $5);}
;

statements : /* empty */|
	statement statements
	;
%%

int main( int argc, char *argv[] )
{
  while (true) {
    printf(">>> ");
    yyparse ();
    yyrestart(yyin);
  }
}

void yyerror (char *s) {/* Called by yyparse on error */
  printf ("%s\n", s);
}
