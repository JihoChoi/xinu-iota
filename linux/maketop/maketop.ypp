/**********************************************************************/
/*	maketop.ypp - input file for the bison parser	              */
/*		      generator. Specifies the grammar for            */
/*		      topologies of nodes in the IoT network          */
/*							              */
/*  The specification for the topology is as follows:		      */
/*	1. The basic elements of the topologies are rings, stars,     */
/*	   complete graphs, other predefined shapes, and individual   */
/*	   nodes. These elements are used to build up the arbitrary   */
/*	   graphs.						      */
/*								      */
/* 	2. The elements that have multiple nodes have a fixed	      */
/*	ordering for the nodes. For example,			      */
/*								      */
/* 	    a. The center of a star is numbered 0, the remaining      */
/* 	       indices number the nodes clockwise. If a spoke node    */
/* 	       is connected first, that becomes 1 (but actually,      */
/* 	       the order doesn't matter).			      */
/*								      */
/*          b. A bus has index 0 for one of the end nodes (the head   */
/*	       if it is	unidirectional) and the numbering proceeds    */
/*	       to the end/tail.					      */
/*								      */
/*          c. When a ring (or complete graph) is connected to        */
/*	       another element, the node that is first connected is   */
/*	       numbered 0, the remaining follow clockwise.            */
/*								      */
/* 	Other kinds of default behavior could be implemented as well. */
/*								      */
/*	3. ->, <- and <-> specify connections between the elements.   */
/*                                                                    */
/*	4. A series of commands can be specified to make the          */
/*	connections.                                                  */
/*                                                                    */
/*	5. For example, a graph like                                  */
/*                                                                    */
/*	    n                  n  n  n                                */
/*	   / \                  \ | /                                 */
/*	  n   n - n - n - n - n - n - n                               */
/*	   \ /                    | \                                 */
/*	    n                     n  n                                */
/*								      */
/*	could be specified using the commands:			      */
/*                                                                    */
/*	a = ring(4);                                                  */
/*	b = bus(3);                                                   */
/*	a <-> b;      // We can have default behaviour for connecting */
/*	              // certain types of elements                    */
/*	c = star(6);                                                  */
/*	b[2] <-> c[0];                                                */
/*	d = node();                                                   */
/*	d <-> c[1];                                                   */
/*	maketop;                                                      */
/*                                                                    */
/*	The graph looks like:                                         */
/*                                                                    */
/*	    a_3                               c_4 c_5 c_6             */
/*         /   \                                 \ | /                */
/*      a_2    a_0 - b_0 - b_1 - b_2 - c_0 - c_1 - d                  */
/*         \   /                                   | \                */
/*          a_1                                   c_3 c_2             */
/*                                                                    */
/*	6. The output would be the usual adjacency list               */
/*	representation, with the nodes named a_0, a_1, b_0, etc.      */
/*								      */
/**********************************************************************/

%start program
%token MAKETOP
%token LEFT RIGHT BI RING EQ LINEAR COMPLETE STAR LEFTPAREN RIGHTPAREN ADD DELETE

%{
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <fstream>
#include <algorithm>

#include <list>
#include <string>

#define NAMLEN 128
#define MAX 45

#define STAR_IN 0
#define STAR_OUT 1
#define STAR_BI 2

#define BIDIREC 0
#define UNIDIREC 1

#ifdef DEBUG
#  define debug(x) x
#else
#  define debug(x)
#endif

void yyerror(const char *s){};
extern "C" int yylex();
extern "C" int yyparse();
extern void yyrestart(FILE *input_file);
extern "C" FILE* yyin;

struct node {
	std::string name;
	std::list<std::string> adj_list;
};

std::list<struct node> nodes;

void add_neighbour(struct node *curr_node, std::string neighbour);
void add_ring(std::string family_name, int n);
void add_linear(std::string family_name, int n);
void add_complete(std::string family_name, int n);
void add_star(std::string family_name, int n, int mode=STAR_BI);
void print_node(struct node curr_node);
void output_to_file();
struct node* node_lookup(std::string name);
void add_connection(struct node &sender, struct node &receiver, int symmetric=0);
void delete_connection(struct node &sender, struct node &receiver, int symmetric=0);

%}

%union {
	int ival;
	char *node_name_value;
}

%token <ival> INT
%token <node_name_value> NODE
%type <node_name_value> node
%type <ival> int_node

%%

program : statements MAKETOP {debug(printf ("End\n")); output_to_file(); exit(1); }
;

statement : assign {printf(">>> ");}| connect {printf(">>> ");}
;

node: NODE
	{
	  $$=$1;
	  std::string name = std::string($1);
	  if (name.length() > NAMLEN) {
	    std::cout << "Node name is too long" << std::endl;
	    YYABORT;
	  }
	}
;

connect : node LEFT node |
	  node RIGHT node |
	  node BI node |
	  ADD node node
		{
                  std::string sender = std::string($2);
		  std::string receiver = std::string($3);
		  add_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  ADD node RIGHT node
		{
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  add_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  ADD node BI node
		{
		  int s = 1;
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  add_connection(*node_lookup(sender), *node_lookup(receiver), s);
		  print_node(*node_lookup(sender));
		} |
	  DELETE node node
		{
		  std::string sender = std::string($2);
		  std::string receiver = std::string($3);
		  delete_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  DELETE node RIGHT node
		{
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  delete_connection(*node_lookup(sender), *node_lookup(receiver));
		  print_node(*node_lookup(sender));
		} |
	  DELETE node BI node
		{
		  int s = 1;
		  std::string sender = std::string($2);
		  std::string receiver = std::string($4);
		  delete_connection(*node_lookup(sender), *node_lookup(receiver), s);
		  print_node(*node_lookup(sender));
		}
;

int_node: INT
{
  $$ = $1;
  if (nodes.size() + $1 > MAX) {
    std::cout << "Node limit exceeded" << std::endl;
    YYABORT;
  }
};

assign : node EQ RING LEFTPAREN int_node RIGHTPAREN
		{add_ring($1, $5);} |
	 node EQ LINEAR LEFTPAREN int_node RIGHTPAREN
		{add_linear($1, $5);} |
	 node EQ COMPLETE LEFTPAREN int_node RIGHTPAREN
		{add_complete($1, $5);} |
	 node EQ STAR LEFTPAREN int_node RIGHTPAREN
		{add_star($1, $5);}
;

statements : /* empty */|
	statement statements
	;
%%

int main( int argc, char *argv[] )
{
  while (true) {
    printf(">>> ");
    yyparse ();
    yyrestart(yyin);
  }
}

void yyerror (char *s) {/* Called by yyparse on error */
  printf ("%s\n", s);
}

int node_check(int n) {
  if (n > MAX)
    return 0;
  return 1;
}

void error_message(std::string msg) {
  std::cerr << msg;
  exit(1);
}

/**************************************************************/
/*	initialize_node - function takes a node to which a    */
/*			neighbour needs to be added, and the  */
/*			name of the neighbour, along with     */
/*			a suffix, if necessary. The suffix is */
/*			a default argument, set at -1. If no  */
/*			suffix is given, the neighbour is     */
/*			added as is.			      */
/**************************************************************/

struct node initialize_node(std::string name, int suffix=-1) {
  struct node new_node;

  /* Initialize name */
  if (suffix != -1)
    name = name + "_" + std::to_string(suffix);

  new_node.name = name;

  /* Clear adjacency list */
  new_node.adj_list.clear();

  debug(std::cout << "\nName: \n" << new_node.name);

  return new_node;
}

/**************************************************************/
/*	add_neighbour - function takes a node to which a      */
/*			neighbour needs to be added, and the  */
/*			name of the neighbour, along with     */
/*			a suffix, if necessary. The suffix is */
/*			a default argument, set at -1. If no  */
/*			suffix is given, the neighbour is     */
/*			added as is.			      */
/**************************************************************/
void add_neighbour(struct node &curr_node, std::string name, int suffix=-1) {
  std::string neighbour_string;

  if (suffix == -1)
    neighbour_string = name;

  else {
    neighbour_string = name + "_" + std::to_string(suffix);
  }

  //TODO: Check for dups in the adjacency list
  curr_node.adj_list.push_back(neighbour_string);
}

void delete_neighbour(struct node &curr_node, std::string name, int suffix=-1) {
  if (suffix == -1)
    name = name;

  else {
    name = name + "_" + std::to_string(suffix);
  }

  curr_node.adj_list.erase(std::remove_if(curr_node.adj_list.begin(),
					  curr_node.adj_list.end(),
					  [=](std::string neighbour) {
						return neighbour == name;
					   }),
			   curr_node.adj_list.end());
}

/**************************************************************/
/*	add_ring - function takes a family_name	and the       */
/*		   number of nodes in the ring, and adds all  */
/*		   nodes to the global nodes list	      */
/**************************************************************/

void add_ring(std::string family_name, int n) {
  int i;				/* index for nodes */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* Loop through nodes in ring */

  for (i = 0; i < n; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Initialize node */
    new_node = initialize_node(family_name, i);

    /* Add first neighbour */
    add_neighbour(new_node, family_name, (((i-1) % n) + n)%n);

    /* Add second neighbour */
    add_neighbour(new_node, family_name, (i+1) % n);

    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }
}

/**************************************************************/
/*	add_linear - function takes a family_name and the     */
/*		   number of nodes in the bus, and adds all   */
/*		   nodes to the global nodes list	      */
/**************************************************************/

void add_linear(std::string family_name, int n) {
  int i = 0;				/* index for nodes */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* For the first node */

  /* Check for node limit */
  if(!node_check(nodes.size()))
    error_message("Node limit exceeded");

  /* Initialize node */
  new_node = initialize_node(family_name, i);

  /* Add first neighbour */
  add_neighbour(new_node, family_name, ((i+1) % n));

  /* Push node on to global nodes list */
  nodes.push_back(new_node);

  /* Print details of node just added */
  print_node(nodes.back());

  /* Loop through nodes in bus */

  for (i = 1; i < n-1; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Initialize next node */
    new_node = initialize_node(family_name, i);

    /* Add first neighbour */
    add_neighbour(new_node, family_name, (((i-1) % n) + n) % n);

    /* Add second neighbour */
    add_neighbour(new_node, family_name, (i+1) % n);

    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }

  /* Last node */

  /* Check for node limit */
  if(!node_check(nodes.size()))
    error_message("Node limit exceeded");

  /* Initialize node */
  new_node = initialize_node(family_name, i);

  /* Add first neighbour */
  add_neighbour(new_node, family_name, (((i-1) % n) + n) % n);

  /* Push node on to global nodes list */
  nodes.push_back(new_node);

  /* Print details of node just added */
  print_node(nodes.back());
}

/**************************************************************/
/*	add_complete - function takes a family_name and the   */
/*		       number of nodes in the complete graph, */
/*		       and adds all nodes to the global nodes */
/*		       list.				      */
/**************************************************************/

void add_complete(std::string family_name, int n) {
  int i, j;				/* indices for nodes */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* Loop through nodes in ring */

  for (i = 0; i < n; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    /* Insert name of next node */
    new_node = initialize_node(family_name, i);

    /* Add all the neighbours */

    for (j = 0; j < n; j++) {
      /* Don't add a node to its own adjacency list */
      if (i == j)
	continue;

      add_neighbour(new_node, family_name, j);
    }
    /* Push node on to global nodes list */
    nodes.push_back(new_node);

    /* Print details of node just added */
    print_node(nodes.back());
  }
}

/**************************************************************/
/*	add_star - function takes a family_name	and the       */
/*		   number of nodes in the star, and adds all  */
/*		   nodes to the global nodes list	      */
/**************************************************************/

void add_star(std::string family_name, int n, int mode) {
  int i = 0, j;				/* index for nodes */
  struct node new_node;			/* struct to hold new node */

  debug(std::cout << "family: " << family_name);

  /* Central node */

  /* Check for node limit */
  if(!node_check(nodes.size()))
    error_message("Node limit exceeded");

  /* Insert name of next node */
  new_node = initialize_node(family_name, i);


  switch(mode) {
  case STAR_BI:
  case STAR_OUT:
    /* Add neighbours */

    for (j = 1; j < n; j++) {
      add_neighbour(new_node, family_name, j);
    }
    break;
  case STAR_IN:
    /* do nothing */
    break;
  default:
    std::cout << "Invalid option";
  }
  /* Push node on to global nodes list */
  nodes.push_back(new_node);

  /* Print details of node just added */
  print_node(nodes.back());

  /* Loop through spokes */

  for (i = 1; i < n; i++) {

    /* Check for node limit */
    if(!node_check(nodes.size()))
      error_message("Node limit exceeded");

    switch(mode) {
    case STAR_BI:
    case STAR_IN:
      /* Insert name of next node */
      new_node = initialize_node(family_name, i);

      /* Add first neighbour */
      add_neighbour(new_node, family_name, 0);

      /* Push node on to global nodes list */
      nodes.push_back(new_node);

      /* Print details of node just added */
      print_node(nodes.back());
      break;
    case STAR_OUT:
      /* do nothing */
      break;
    }
  }
}

/**************************************************************/
/*	print_node - Print the details of a single node       */
/**************************************************************/

void print_node(struct node curr_node) {
  std::cout << "\nNode name: " << curr_node.name;
  std::cout << "\nNumber of adjacent nodes: " << curr_node.adj_list.size();
  std::cout << "\nAdjacent nodes: ";

  for(std::list<std::string>::iterator iter = curr_node.adj_list.begin(); iter != curr_node.adj_list.end(); iter++){
	std::cout << *iter << " ";;
  }

  std::cout << std::endl << std::endl;
}

/**************************************************************/
/*	output_to_file - Write the adjacency lists to file    */
/**************************************************************/

void output_to_file() {
	std::string filename = "output_file";

	std::ofstream fout(filename);

	for(std::list<struct node>::iterator curr_node = nodes.begin(); curr_node != nodes.end(); curr_node++) {
		fout << (*curr_node).name << ":";
		for(std::list<std::string>::iterator curr_element = (*curr_node).adj_list.begin(); curr_element != (*curr_node).adj_list.end(); curr_element++){
			 fout << " " << *curr_element;
		}
		fout << std::endl;
	}
	fout.close();
}


/****************************************************************/
/*	node_lookup - accepts a node's name and checks if it is */
/*		      already there, and if it is, returns the  */
/*		      node, otherwise returns NULL.		*/
/****************************************************************/

struct node* node_lookup(std::string name) {
	for(std::list<struct node>::iterator curr_node = nodes.begin(); curr_node != nodes.end(); curr_node++) {
	  if ((*curr_node).name == name)
	    return &(*curr_node);
	}
	return NULL;
}

/****************************************************************/
/*	add_connection - adds receiver as a neighbour to sender	*/
/*			 Takes sender and receiver as arguments	*/
/*			 along with a symmetry option		*/
/****************************************************************/

void add_connection(struct node &sender, struct node &receiver, int symmetric) {
  add_neighbour(sender, receiver.name);
  if(symmetric) {
	add_neighbour(receiver, sender.name);
  }
}


/****************************************************************/
/*	delete_connection - deletes receiver as a neighbour to sender	*/
/*			 Takes sender and receiver as arguments	*/
/*			 along with a symmetry option		*/
/****************************************************************/

void delete_connection(struct node &sender, struct node &receiver, int symmetric) {
  delete_neighbour(sender, receiver.name);
  if(symmetric) {
	delete_neighbour(receiver, sender.name);
  }
}
